#!/usr/bin/env node
"use strict";
/**
 * FDD Inject Context Hook - Auto-generated by fdd-cli
 * DO NOT EDIT MANUALLY - regenerated on each fdd add
 *
 * PreToolUse hook that injects context before Edit/Write/MultiEdit operations
 * Uses deny + permissionDecisionReason to inject context into Claude's thinking
 */

const fs = require("node:fs");
const path = require("node:path");
const { minimatch } = require("minimatch");

const INJECT_CONTEXT_RULES = [
	{
		pitfallId: "PIT-002",
		pitfallTitle: "[示例] 触发器开发规范提醒",
		pitfallFilename: "pit-002-untitled.md",
		triggerIndex: 0,
		whenTouching: ["src/lib/trigger/**"],
		exclude: [],
		context:
			"触发器开发规范：\n1. 每个触发器在 src/lib/trigger/{kind}.ts 实现\n2. 在 src/lib/trigger/types.ts 添加类型\n3. 在 src/lib/schema.ts 添加 Zod schema\n4. 添加单元测试 src/__tests__/trigger/{kind}.test.ts\n",
	},
];

// State file to track already-intercepted files (avoid infinite loop)
const STATE_FILE = path.join(__dirname, ".inject-state.json");

let inputData = "";
process.stdin.setEncoding("utf8");
process.stdin.on("data", (chunk) => {
	inputData += chunk;
});
process.stdin.on("end", () => {
	try {
		handlePreToolUse(JSON.parse(inputData));
	} catch (_error) {
		// On error, allow the operation to continue
		outputAllow();
	}
});

function handlePreToolUse(data) {
	const toolName = data.tool_name;
	const toolInput = data.tool_input || {};

	// Only process Edit, Write, MultiEdit tools
	if (toolName !== "Edit" && toolName !== "Write" && toolName !== "MultiEdit") {
		outputAllow();
		return;
	}

	const filePath = toolInput.file_path || "";
	if (!filePath) {
		outputAllow();
		return;
	}

	// Normalize file path to relative path
	const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();
	let normalizedPath = filePath.replace(/^\.\//g, "");
	if (path.isAbsolute(normalizedPath)) {
		normalizedPath = path.relative(projectDir, normalizedPath);
	}

	// Find matching rules
	const matchedRules = findMatchingRules(normalizedPath);
	if (matchedRules.length === 0) {
		outputAllow();
		return;
	}

	// Check state - have we already intercepted this file?
	// Using pure path as key (no session isolation - once warned, always remembered)
	const stateKey = normalizedPath;
	const state = loadState();

	if (state[stateKey]) {
		// Already intercepted, allow
		outputAllow();
		return;
	}

	// First interception - record state and deny with context
	state[stateKey] = {
		timestamp: Date.now(),
		tool: toolName,
		pitfallIds: matchedRules.map((r) => r.pitfallId),
	};
	saveState(state);

	// Build the context message (inline all context content)
	const contextMessage = buildContextMessage(matchedRules, normalizedPath);

	// Output deny with the context as reason
	outputDeny(contextMessage);
}

function findMatchingRules(filePath) {
	const matched = [];

	for (const rule of INJECT_CONTEXT_RULES) {
		let isMatch = false;

		// Check when_touching patterns
		for (const pattern of rule.whenTouching) {
			if (
				minimatch(filePath, pattern) ||
				filePath.includes(pattern.replace(/\*\*/g, "").replace(/\*/g, ""))
			) {
				isMatch = true;
				break;
			}
		}

		if (!isMatch) {
			continue;
		}

		// Check exclude patterns
		const isExcluded = rule.exclude.some((excl) => minimatch(filePath, excl));
		if (isExcluded) {
			continue;
		}

		matched.push(rule);
	}

	return matched;
}

function buildContextMessage(rules, filePath) {
	const parts = [];

	parts.push(`[FDD] 编辑 ${filePath} 前请注意以下历史问题:\n`);

	for (const rule of rules) {
		parts.push(`### [${rule.pitfallId}] ${rule.pitfallTitle}\n`);
		parts.push(rule.context);
		parts.push("");
	}

	parts.push("请继续编辑。");

	return parts.join("\n");
}

function outputAllow() {
	const output = {
		hookSpecificOutput: {
			hookEventName: "PreToolUse",
			permissionDecision: "allow",
		},
	};
	console.log(JSON.stringify(output));
	process.exit(0);
}

function outputDeny(reason) {
	const output = {
		hookSpecificOutput: {
			hookEventName: "PreToolUse",
			permissionDecision: "deny",
			permissionDecisionReason: reason,
		},
	};
	console.log(JSON.stringify(output));
	process.exit(0);
}

function loadState() {
	try {
		if (fs.existsSync(STATE_FILE)) {
			return JSON.parse(fs.readFileSync(STATE_FILE, "utf8"));
		}
	} catch (_e) {}
	return {};
}

function saveState(state) {
	try {
		fs.writeFileSync(STATE_FILE, JSON.stringify(state, null, 2));
	} catch (_e) {}
}
